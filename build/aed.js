// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: aed.proto
/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "./google/protobuf/timestamp";
import { MetaData } from "./sologenic/com-fs-utils-lib/models/metadata/metadata";
export const protobufPackage = "aed";
export var Source;
(function (Source) {
    Source[Source["SOURCE_NOT_USED"] = 0] = "SOURCE_NOT_USED";
    /** SOURCE_EXCHANGE - Source: exchange trades */
    Source[Source["SOURCE_EXCHANGE"] = 1] = "SOURCE_EXCHANGE";
    /** SOURCE_ATS - Alternative Trading System */
    Source[Source["SOURCE_ATS"] = 2] = "SOURCE_ATS";
    /** SOURCE_DEX - Decentralized Exchange + AMM (anywhere on the blockchain) */
    Source[Source["SOURCE_DEX"] = 3] = "SOURCE_DEX";
    Source[Source["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Source || (Source = {}));
export function sourceFromJSON(object) {
    switch (object) {
        case 0:
        case "SOURCE_NOT_USED":
            return Source.SOURCE_NOT_USED;
        case 1:
        case "SOURCE_EXCHANGE":
            return Source.SOURCE_EXCHANGE;
        case 2:
        case "SOURCE_ATS":
            return Source.SOURCE_ATS;
        case 3:
        case "SOURCE_DEX":
            return Source.SOURCE_DEX;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Source.UNRECOGNIZED;
    }
}
export function sourceToJSON(object) {
    switch (object) {
        case Source.SOURCE_NOT_USED:
            return "SOURCE_NOT_USED";
        case Source.SOURCE_EXCHANGE:
            return "SOURCE_EXCHANGE";
        case Source.SOURCE_ATS:
            return "SOURCE_ATS";
        case Source.SOURCE_DEX:
            return "SOURCE_DEX";
        case Source.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var Series;
(function (Series) {
    Series[Series["SERIES_NOT_USED"] = 0] = "SERIES_NOT_USED";
    /** INTERNAL_TRADES - Source: dex trades, Usage: general trade graphs, supports TradeView-like graphing tools (ohlc) */
    Series[Series["INTERNAL_TRADES"] = 1] = "INTERNAL_TRADES";
    /** MARKET_DATA_STOCKS - Source: external market data provider for the general stock market (can be more than 1 provider, but only a single provider per stock) */
    Series[Series["MARKET_DATA_STOCKS"] = 2] = "MARKET_DATA_STOCKS";
    /** USER_PERFORMANCE - Source: user account data, Usage: tracks user's portfolio/trading performance over various time periods */
    Series[Series["USER_PERFORMANCE"] = 3] = "USER_PERFORMANCE";
    Series[Series["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Series || (Series = {}));
export function seriesFromJSON(object) {
    switch (object) {
        case 0:
        case "SERIES_NOT_USED":
            return Series.SERIES_NOT_USED;
        case 1:
        case "INTERNAL_TRADES":
            return Series.INTERNAL_TRADES;
        case 2:
        case "MARKET_DATA_STOCKS":
            return Series.MARKET_DATA_STOCKS;
        case 3:
        case "USER_PERFORMANCE":
            return Series.USER_PERFORMANCE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Series.UNRECOGNIZED;
    }
}
export function seriesToJSON(object) {
    switch (object) {
        case Series.SERIES_NOT_USED:
            return "SERIES_NOT_USED";
        case Series.INTERNAL_TRADES:
            return "INTERNAL_TRADES";
        case Series.MARKET_DATA_STOCKS:
            return "MARKET_DATA_STOCKS";
        case Series.USER_PERFORMANCE:
            return "USER_PERFORMANCE";
        case Series.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var Field;
(function (Field) {
    Field[Field["FIELD_NOT_USED"] = 0] = "FIELD_NOT_USED";
    Field[Field["OPEN"] = 1] = "OPEN";
    Field[Field["HIGH"] = 2] = "HIGH";
    Field[Field["LOW"] = 3] = "LOW";
    Field[Field["CLOSE"] = 4] = "CLOSE";
    Field[Field["VOLUME"] = 5] = "VOLUME";
    Field[Field["NUMBER_OF_TRADES"] = 6] = "NUMBER_OF_TRADES";
    Field[Field["INVERTED_VOLUME"] = 7] = "INVERTED_VOLUME";
    Field[Field["MARKET_CAP"] = 8] = "MARKET_CAP";
    Field[Field["EPS"] = 9] = "EPS";
    Field[Field["PE_RATIO"] = 10] = "PE_RATIO";
    Field[Field["YIELD"] = 11] = "YIELD";
    Field[Field["OPEN_TIME"] = 12] = "OPEN_TIME";
    Field[Field["CLOSE_TIME"] = 13] = "CLOSE_TIME";
    /** FIRST_PRICE - First price in the time window */
    Field[Field["FIRST_PRICE"] = 14] = "FIRST_PRICE";
    /** LAST_PRICE - Last price in the time window */
    Field[Field["LAST_PRICE"] = 15] = "LAST_PRICE";
    Field[Field["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Field || (Field = {}));
export function fieldFromJSON(object) {
    switch (object) {
        case 0:
        case "FIELD_NOT_USED":
            return Field.FIELD_NOT_USED;
        case 1:
        case "OPEN":
            return Field.OPEN;
        case 2:
        case "HIGH":
            return Field.HIGH;
        case 3:
        case "LOW":
            return Field.LOW;
        case 4:
        case "CLOSE":
            return Field.CLOSE;
        case 5:
        case "VOLUME":
            return Field.VOLUME;
        case 6:
        case "NUMBER_OF_TRADES":
            return Field.NUMBER_OF_TRADES;
        case 7:
        case "INVERTED_VOLUME":
            return Field.INVERTED_VOLUME;
        case 8:
        case "MARKET_CAP":
            return Field.MARKET_CAP;
        case 9:
        case "EPS":
            return Field.EPS;
        case 10:
        case "PE_RATIO":
            return Field.PE_RATIO;
        case 11:
        case "YIELD":
            return Field.YIELD;
        case 12:
        case "OPEN_TIME":
            return Field.OPEN_TIME;
        case 13:
        case "CLOSE_TIME":
            return Field.CLOSE_TIME;
        case 14:
        case "FIRST_PRICE":
            return Field.FIRST_PRICE;
        case 15:
        case "LAST_PRICE":
            return Field.LAST_PRICE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Field.UNRECOGNIZED;
    }
}
export function fieldToJSON(object) {
    switch (object) {
        case Field.FIELD_NOT_USED:
            return "FIELD_NOT_USED";
        case Field.OPEN:
            return "OPEN";
        case Field.HIGH:
            return "HIGH";
        case Field.LOW:
            return "LOW";
        case Field.CLOSE:
            return "CLOSE";
        case Field.VOLUME:
            return "VOLUME";
        case Field.NUMBER_OF_TRADES:
            return "NUMBER_OF_TRADES";
        case Field.INVERTED_VOLUME:
            return "INVERTED_VOLUME";
        case Field.MARKET_CAP:
            return "MARKET_CAP";
        case Field.EPS:
            return "EPS";
        case Field.PE_RATIO:
            return "PE_RATIO";
        case Field.YIELD:
            return "YIELD";
        case Field.OPEN_TIME:
            return "OPEN_TIME";
        case Field.CLOSE_TIME:
            return "CLOSE_TIME";
        case Field.FIRST_PRICE:
            return "FIRST_PRICE";
        case Field.LAST_PRICE:
            return "LAST_PRICE";
        case Field.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var PeriodType;
(function (PeriodType) {
    PeriodType[PeriodType["PERIOD_TYPE_DO_NOT_USE"] = 0] = "PERIOD_TYPE_DO_NOT_USE";
    PeriodType[PeriodType["PERIOD_TYPE_MINUTE"] = 1] = "PERIOD_TYPE_MINUTE";
    PeriodType[PeriodType["PERIOD_TYPE_HOUR"] = 2] = "PERIOD_TYPE_HOUR";
    PeriodType[PeriodType["PERIOD_TYPE_DAY"] = 3] = "PERIOD_TYPE_DAY";
    PeriodType[PeriodType["PERIOD_TYPE_WEEK"] = 4] = "PERIOD_TYPE_WEEK";
    PeriodType[PeriodType["PERIOD_TYPE_MONTH"] = 5] = "PERIOD_TYPE_MONTH";
    PeriodType[PeriodType["PERIOD_TYPE_YEAR"] = 6] = "PERIOD_TYPE_YEAR";
    PeriodType[PeriodType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PeriodType || (PeriodType = {}));
export function periodTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "PERIOD_TYPE_DO_NOT_USE":
            return PeriodType.PERIOD_TYPE_DO_NOT_USE;
        case 1:
        case "PERIOD_TYPE_MINUTE":
            return PeriodType.PERIOD_TYPE_MINUTE;
        case 2:
        case "PERIOD_TYPE_HOUR":
            return PeriodType.PERIOD_TYPE_HOUR;
        case 3:
        case "PERIOD_TYPE_DAY":
            return PeriodType.PERIOD_TYPE_DAY;
        case 4:
        case "PERIOD_TYPE_WEEK":
            return PeriodType.PERIOD_TYPE_WEEK;
        case 5:
        case "PERIOD_TYPE_MONTH":
            return PeriodType.PERIOD_TYPE_MONTH;
        case 6:
        case "PERIOD_TYPE_YEAR":
            return PeriodType.PERIOD_TYPE_YEAR;
        case -1:
        case "UNRECOGNIZED":
        default:
            return PeriodType.UNRECOGNIZED;
    }
}
export function periodTypeToJSON(object) {
    switch (object) {
        case PeriodType.PERIOD_TYPE_DO_NOT_USE:
            return "PERIOD_TYPE_DO_NOT_USE";
        case PeriodType.PERIOD_TYPE_MINUTE:
            return "PERIOD_TYPE_MINUTE";
        case PeriodType.PERIOD_TYPE_HOUR:
            return "PERIOD_TYPE_HOUR";
        case PeriodType.PERIOD_TYPE_DAY:
            return "PERIOD_TYPE_DAY";
        case PeriodType.PERIOD_TYPE_WEEK:
            return "PERIOD_TYPE_WEEK";
        case PeriodType.PERIOD_TYPE_MONTH:
            return "PERIOD_TYPE_MONTH";
        case PeriodType.PERIOD_TYPE_YEAR:
            return "PERIOD_TYPE_YEAR";
        case PeriodType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseAEDs() {
    return { AEDs: [] };
}
export const AEDs = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.AEDs) {
            AED.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAEDs();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.AEDs.push(AED.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { AEDs: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.AEDs) ? object.AEDs.map((e) => AED.fromJSON(e)) : [] };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if ((_a = message.AEDs) === null || _a === void 0 ? void 0 : _a.length) {
            obj.AEDs = message.AEDs.map((e) => AED.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return AEDs.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseAEDs();
        message.AEDs = ((_a = object.AEDs) === null || _a === void 0 ? void 0 : _a.map((e) => AED.fromPartial(e))) || [];
        return message;
    },
};
function createBaseAED() {
    return {
        OrganizationID: "",
        Symbol: "",
        Timestamp: undefined,
        Period: undefined,
        MetaData: undefined,
        UserID: undefined,
        Value: [],
        Series: 0,
        Source: undefined,
    };
}
export const AED = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.OrganizationID !== "") {
            writer.uint32(10).string(message.OrganizationID);
        }
        if (message.Symbol !== "") {
            writer.uint32(18).string(message.Symbol);
        }
        if (message.Timestamp !== undefined) {
            Timestamp.encode(toTimestamp(message.Timestamp), writer.uint32(26).fork()).ldelim();
        }
        if (message.Period !== undefined) {
            Period.encode(message.Period, writer.uint32(34).fork()).ldelim();
        }
        if (message.MetaData !== undefined) {
            MetaData.encode(message.MetaData, writer.uint32(42).fork()).ldelim();
        }
        if (message.UserID !== undefined) {
            writer.uint32(50).string(message.UserID);
        }
        for (const v of message.Value) {
            Value.encode(v, writer.uint32(802).fork()).ldelim();
        }
        if (message.Series !== 0) {
            writer.uint32(808).int32(message.Series);
        }
        if (message.Source !== undefined) {
            writer.uint32(816).int32(message.Source);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAED();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.OrganizationID = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.Symbol = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.Timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.Period = Period.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.MetaData = MetaData.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.UserID = reader.string();
                    continue;
                case 100:
                    if (tag !== 802) {
                        break;
                    }
                    message.Value.push(Value.decode(reader, reader.uint32()));
                    continue;
                case 101:
                    if (tag !== 808) {
                        break;
                    }
                    message.Series = reader.int32();
                    continue;
                case 102:
                    if (tag !== 816) {
                        break;
                    }
                    message.Source = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : "",
            Symbol: isSet(object.Symbol) ? globalThis.String(object.Symbol) : "",
            Timestamp: isSet(object.Timestamp) ? fromJsonTimestamp(object.Timestamp) : undefined,
            Period: isSet(object.Period) ? Period.fromJSON(object.Period) : undefined,
            MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
            UserID: isSet(object.UserID) ? globalThis.String(object.UserID) : undefined,
            Value: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.Value) ? object.Value.map((e) => Value.fromJSON(e)) : [],
            Series: isSet(object.Series) ? seriesFromJSON(object.Series) : 0,
            Source: isSet(object.Source) ? sourceFromJSON(object.Source) : undefined,
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if (message.OrganizationID !== "") {
            obj.OrganizationID = message.OrganizationID;
        }
        if (message.Symbol !== "") {
            obj.Symbol = message.Symbol;
        }
        if (message.Timestamp !== undefined) {
            obj.Timestamp = message.Timestamp.toISOString();
        }
        if (message.Period !== undefined) {
            obj.Period = Period.toJSON(message.Period);
        }
        if (message.MetaData !== undefined) {
            obj.MetaData = MetaData.toJSON(message.MetaData);
        }
        if (message.UserID !== undefined) {
            obj.UserID = message.UserID;
        }
        if ((_a = message.Value) === null || _a === void 0 ? void 0 : _a.length) {
            obj.Value = message.Value.map((e) => Value.toJSON(e));
        }
        if (message.Series !== 0) {
            obj.Series = seriesToJSON(message.Series);
        }
        if (message.Source !== undefined) {
            obj.Source = sourceToJSON(message.Source);
        }
        return obj;
    },
    create(base) {
        return AED.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseAED();
        message.OrganizationID = (_a = object.OrganizationID) !== null && _a !== void 0 ? _a : "";
        message.Symbol = (_b = object.Symbol) !== null && _b !== void 0 ? _b : "";
        message.Timestamp = (_c = object.Timestamp) !== null && _c !== void 0 ? _c : undefined;
        message.Period = (object.Period !== undefined && object.Period !== null)
            ? Period.fromPartial(object.Period)
            : undefined;
        message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
            ? MetaData.fromPartial(object.MetaData)
            : undefined;
        message.UserID = (_d = object.UserID) !== null && _d !== void 0 ? _d : undefined;
        message.Value = ((_e = object.Value) === null || _e === void 0 ? void 0 : _e.map((e) => Value.fromPartial(e))) || [];
        message.Series = (_f = object.Series) !== null && _f !== void 0 ? _f : 0;
        message.Source = (_g = object.Source) !== null && _g !== void 0 ? _g : undefined;
        return message;
    },
};
function createBaseValue() {
    return { Field: 0, StringVal: undefined, Int64Val: undefined, Float64Val: undefined, BoolVal: undefined };
}
export const Value = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.Field !== 0) {
            writer.uint32(8).int32(message.Field);
        }
        if (message.StringVal !== undefined) {
            writer.uint32(18).string(message.StringVal);
        }
        if (message.Int64Val !== undefined) {
            writer.uint32(24).int64(message.Int64Val);
        }
        if (message.Float64Val !== undefined) {
            writer.uint32(33).double(message.Float64Val);
        }
        if (message.BoolVal !== undefined) {
            writer.uint32(40).bool(message.BoolVal);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.Field = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.StringVal = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.Int64Val = longToNumber(reader.int64());
                    continue;
                case 4:
                    if (tag !== 33) {
                        break;
                    }
                    message.Float64Val = reader.double();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.BoolVal = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            Field: isSet(object.Field) ? fieldFromJSON(object.Field) : 0,
            StringVal: isSet(object.StringVal) ? globalThis.String(object.StringVal) : undefined,
            Int64Val: isSet(object.Int64Val) ? globalThis.Number(object.Int64Val) : undefined,
            Float64Val: isSet(object.Float64Val) ? globalThis.Number(object.Float64Val) : undefined,
            BoolVal: isSet(object.BoolVal) ? globalThis.Boolean(object.BoolVal) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.Field !== 0) {
            obj.Field = fieldToJSON(message.Field);
        }
        if (message.StringVal !== undefined) {
            obj.StringVal = message.StringVal;
        }
        if (message.Int64Val !== undefined) {
            obj.Int64Val = Math.round(message.Int64Val);
        }
        if (message.Float64Val !== undefined) {
            obj.Float64Val = message.Float64Val;
        }
        if (message.BoolVal !== undefined) {
            obj.BoolVal = message.BoolVal;
        }
        return obj;
    },
    create(base) {
        return Value.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseValue();
        message.Field = (_a = object.Field) !== null && _a !== void 0 ? _a : 0;
        message.StringVal = (_b = object.StringVal) !== null && _b !== void 0 ? _b : undefined;
        message.Int64Val = (_c = object.Int64Val) !== null && _c !== void 0 ? _c : undefined;
        message.Float64Val = (_d = object.Float64Val) !== null && _d !== void 0 ? _d : undefined;
        message.BoolVal = (_e = object.BoolVal) !== null && _e !== void 0 ? _e : undefined;
        return message;
    },
};
function createBasePeriod() {
    return { Type: 0, Duration: 0 };
}
export const Period = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.Type !== 0) {
            writer.uint32(8).int32(message.Type);
        }
        if (message.Duration !== 0) {
            writer.uint32(16).int32(message.Duration);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePeriod();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.Type = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.Duration = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            Type: isSet(object.Type) ? periodTypeFromJSON(object.Type) : 0,
            Duration: isSet(object.Duration) ? globalThis.Number(object.Duration) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.Type !== 0) {
            obj.Type = periodTypeToJSON(message.Type);
        }
        if (message.Duration !== 0) {
            obj.Duration = Math.round(message.Duration);
        }
        return obj;
    },
    create(base) {
        return Period.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePeriod();
        message.Type = (_a = object.Type) !== null && _a !== void 0 ? _a : 0;
        message.Duration = (_b = object.Duration) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function longToNumber(long) {
    if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
