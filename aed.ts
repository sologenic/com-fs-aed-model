// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.1
// source: aed.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "./google/protobuf/timestamp";
import { MetaData } from "./sologenic/com-fs-utils-lib/models/metadata/metadata";

export const protobufPackage = "aed";

export enum Source {
  SOURCE_NOT_USED = 0,
  /** SOURCE_EXCHANGE - Source: exchange trades */
  SOURCE_EXCHANGE = 1,
  /** SOURCE_ATS - Alternative Trading System */
  SOURCE_ATS = 2,
  /** SOURCE_DEX - Decentralized Exchange + AMM (anywhere on the blockchain) */
  SOURCE_DEX = 3,
  UNRECOGNIZED = -1,
}

export function sourceFromJSON(object: any): Source {
  switch (object) {
    case 0:
    case "SOURCE_NOT_USED":
      return Source.SOURCE_NOT_USED;
    case 1:
    case "SOURCE_EXCHANGE":
      return Source.SOURCE_EXCHANGE;
    case 2:
    case "SOURCE_ATS":
      return Source.SOURCE_ATS;
    case 3:
    case "SOURCE_DEX":
      return Source.SOURCE_DEX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Source.UNRECOGNIZED;
  }
}

export function sourceToJSON(object: Source): string {
  switch (object) {
    case Source.SOURCE_NOT_USED:
      return "SOURCE_NOT_USED";
    case Source.SOURCE_EXCHANGE:
      return "SOURCE_EXCHANGE";
    case Source.SOURCE_ATS:
      return "SOURCE_ATS";
    case Source.SOURCE_DEX:
      return "SOURCE_DEX";
    case Source.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Series {
  SERIES_NOT_USED = 0,
  /** INTERNAL_TRADES - Source: dex trades, Usage: general trade graphs, supports TradeView-like graphing tools (ohlc) */
  INTERNAL_TRADES = 1,
  /** MARKET_DATA_STOCKS - Source: external market data provider for the general stock market (can be more than 1 provider, but only a single provider per stock) */
  MARKET_DATA_STOCKS = 2,
  /** USER_PERFORMANCE - Source: user account data, Usage: tracks user's portfolio/trading performance over various time periods */
  USER_PERFORMANCE = 3,
  UNRECOGNIZED = -1,
}

export function seriesFromJSON(object: any): Series {
  switch (object) {
    case 0:
    case "SERIES_NOT_USED":
      return Series.SERIES_NOT_USED;
    case 1:
    case "INTERNAL_TRADES":
      return Series.INTERNAL_TRADES;
    case 2:
    case "MARKET_DATA_STOCKS":
      return Series.MARKET_DATA_STOCKS;
    case 3:
    case "USER_PERFORMANCE":
      return Series.USER_PERFORMANCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Series.UNRECOGNIZED;
  }
}

export function seriesToJSON(object: Series): string {
  switch (object) {
    case Series.SERIES_NOT_USED:
      return "SERIES_NOT_USED";
    case Series.INTERNAL_TRADES:
      return "INTERNAL_TRADES";
    case Series.MARKET_DATA_STOCKS:
      return "MARKET_DATA_STOCKS";
    case Series.USER_PERFORMANCE:
      return "USER_PERFORMANCE";
    case Series.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Field {
  FIELD_NOT_USED = 0,
  OPEN = 1,
  HIGH = 2,
  LOW = 3,
  CLOSE = 4,
  VOLUME = 5,
  NUMBER_OF_TRADES = 6,
  INVERTED_VOLUME = 7,
  MARKET_CAP = 8,
  EPS = 9,
  PE_RATIO = 10,
  YIELD = 11,
  OPEN_TIME = 12,
  CLOSE_TIME = 13,
  /** FIRST_PRICE - First price in the time window */
  FIRST_PRICE = 14,
  /** LAST_PRICE - Last price in the time window */
  LAST_PRICE = 15,
  UNRECOGNIZED = -1,
}

export function fieldFromJSON(object: any): Field {
  switch (object) {
    case 0:
    case "FIELD_NOT_USED":
      return Field.FIELD_NOT_USED;
    case 1:
    case "OPEN":
      return Field.OPEN;
    case 2:
    case "HIGH":
      return Field.HIGH;
    case 3:
    case "LOW":
      return Field.LOW;
    case 4:
    case "CLOSE":
      return Field.CLOSE;
    case 5:
    case "VOLUME":
      return Field.VOLUME;
    case 6:
    case "NUMBER_OF_TRADES":
      return Field.NUMBER_OF_TRADES;
    case 7:
    case "INVERTED_VOLUME":
      return Field.INVERTED_VOLUME;
    case 8:
    case "MARKET_CAP":
      return Field.MARKET_CAP;
    case 9:
    case "EPS":
      return Field.EPS;
    case 10:
    case "PE_RATIO":
      return Field.PE_RATIO;
    case 11:
    case "YIELD":
      return Field.YIELD;
    case 12:
    case "OPEN_TIME":
      return Field.OPEN_TIME;
    case 13:
    case "CLOSE_TIME":
      return Field.CLOSE_TIME;
    case 14:
    case "FIRST_PRICE":
      return Field.FIRST_PRICE;
    case 15:
    case "LAST_PRICE":
      return Field.LAST_PRICE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Field.UNRECOGNIZED;
  }
}

export function fieldToJSON(object: Field): string {
  switch (object) {
    case Field.FIELD_NOT_USED:
      return "FIELD_NOT_USED";
    case Field.OPEN:
      return "OPEN";
    case Field.HIGH:
      return "HIGH";
    case Field.LOW:
      return "LOW";
    case Field.CLOSE:
      return "CLOSE";
    case Field.VOLUME:
      return "VOLUME";
    case Field.NUMBER_OF_TRADES:
      return "NUMBER_OF_TRADES";
    case Field.INVERTED_VOLUME:
      return "INVERTED_VOLUME";
    case Field.MARKET_CAP:
      return "MARKET_CAP";
    case Field.EPS:
      return "EPS";
    case Field.PE_RATIO:
      return "PE_RATIO";
    case Field.YIELD:
      return "YIELD";
    case Field.OPEN_TIME:
      return "OPEN_TIME";
    case Field.CLOSE_TIME:
      return "CLOSE_TIME";
    case Field.FIRST_PRICE:
      return "FIRST_PRICE";
    case Field.LAST_PRICE:
      return "LAST_PRICE";
    case Field.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PeriodType {
  PERIOD_TYPE_DO_NOT_USE = 0,
  PERIOD_TYPE_MINUTE = 1,
  PERIOD_TYPE_HOUR = 2,
  PERIOD_TYPE_DAY = 3,
  PERIOD_TYPE_WEEK = 4,
  PERIOD_TYPE_MONTH = 5,
  PERIOD_TYPE_YEAR = 6,
  UNRECOGNIZED = -1,
}

export function periodTypeFromJSON(object: any): PeriodType {
  switch (object) {
    case 0:
    case "PERIOD_TYPE_DO_NOT_USE":
      return PeriodType.PERIOD_TYPE_DO_NOT_USE;
    case 1:
    case "PERIOD_TYPE_MINUTE":
      return PeriodType.PERIOD_TYPE_MINUTE;
    case 2:
    case "PERIOD_TYPE_HOUR":
      return PeriodType.PERIOD_TYPE_HOUR;
    case 3:
    case "PERIOD_TYPE_DAY":
      return PeriodType.PERIOD_TYPE_DAY;
    case 4:
    case "PERIOD_TYPE_WEEK":
      return PeriodType.PERIOD_TYPE_WEEK;
    case 5:
    case "PERIOD_TYPE_MONTH":
      return PeriodType.PERIOD_TYPE_MONTH;
    case 6:
    case "PERIOD_TYPE_YEAR":
      return PeriodType.PERIOD_TYPE_YEAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PeriodType.UNRECOGNIZED;
  }
}

export function periodTypeToJSON(object: PeriodType): string {
  switch (object) {
    case PeriodType.PERIOD_TYPE_DO_NOT_USE:
      return "PERIOD_TYPE_DO_NOT_USE";
    case PeriodType.PERIOD_TYPE_MINUTE:
      return "PERIOD_TYPE_MINUTE";
    case PeriodType.PERIOD_TYPE_HOUR:
      return "PERIOD_TYPE_HOUR";
    case PeriodType.PERIOD_TYPE_DAY:
      return "PERIOD_TYPE_DAY";
    case PeriodType.PERIOD_TYPE_WEEK:
      return "PERIOD_TYPE_WEEK";
    case PeriodType.PERIOD_TYPE_MONTH:
      return "PERIOD_TYPE_MONTH";
    case PeriodType.PERIOD_TYPE_YEAR:
      return "PERIOD_TYPE_YEAR";
    case PeriodType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AEDs {
  AEDs: AED[];
}

export interface AED {
  OrganizationID: string;
  /** Denom1:Denom2 */
  Symbol: string;
  Timestamp: Date | undefined;
  Period: Period | undefined;
  MetaData:
    | MetaData
    | undefined;
  /** Time series stored at user level for profit/loss, etc */
  UserID?: string | undefined;
  Value: Value[];
  Series: Series;
  Source?: Source | undefined;
}

export interface Value {
  Field: Field;
  /** String value */
  StringVal?:
    | string
    | undefined;
  /** Integer value */
  Int64Val?:
    | number
    | undefined;
  /** Float value */
  Float64Val?:
    | number
    | undefined;
  /** Boolean value */
  BoolVal?: boolean | undefined;
}

export interface Period {
  Type: PeriodType;
  /** The duration of the indicated period (e.g 1 minute, 3 minutes, etc) */
  Duration: number;
}

function createBaseAEDs(): AEDs {
  return { AEDs: [] };
}

export const AEDs = {
  encode(message: AEDs, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.AEDs) {
      AED.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AEDs {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAEDs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.AEDs.push(AED.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AEDs {
    return { AEDs: globalThis.Array.isArray(object?.AEDs) ? object.AEDs.map((e: any) => AED.fromJSON(e)) : [] };
  },

  toJSON(message: AEDs): unknown {
    const obj: any = {};
    if (message.AEDs?.length) {
      obj.AEDs = message.AEDs.map((e) => AED.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AEDs>, I>>(base?: I): AEDs {
    return AEDs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AEDs>, I>>(object: I): AEDs {
    const message = createBaseAEDs();
    message.AEDs = object.AEDs?.map((e) => AED.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAED(): AED {
  return {
    OrganizationID: "",
    Symbol: "",
    Timestamp: undefined,
    Period: undefined,
    MetaData: undefined,
    UserID: undefined,
    Value: [],
    Series: 0,
    Source: undefined,
  };
}

export const AED = {
  encode(message: AED, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.OrganizationID !== "") {
      writer.uint32(10).string(message.OrganizationID);
    }
    if (message.Symbol !== "") {
      writer.uint32(18).string(message.Symbol);
    }
    if (message.Timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.Timestamp), writer.uint32(26).fork()).ldelim();
    }
    if (message.Period !== undefined) {
      Period.encode(message.Period, writer.uint32(34).fork()).ldelim();
    }
    if (message.MetaData !== undefined) {
      MetaData.encode(message.MetaData, writer.uint32(42).fork()).ldelim();
    }
    if (message.UserID !== undefined) {
      writer.uint32(50).string(message.UserID);
    }
    for (const v of message.Value) {
      Value.encode(v!, writer.uint32(802).fork()).ldelim();
    }
    if (message.Series !== 0) {
      writer.uint32(808).int32(message.Series);
    }
    if (message.Source !== undefined) {
      writer.uint32(816).int32(message.Source);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AED {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAED();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.OrganizationID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Symbol = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.Timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.Period = Period.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.MetaData = MetaData.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.UserID = reader.string();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.Value.push(Value.decode(reader, reader.uint32()));
          continue;
        case 101:
          if (tag !== 808) {
            break;
          }

          message.Series = reader.int32() as any;
          continue;
        case 102:
          if (tag !== 816) {
            break;
          }

          message.Source = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AED {
    return {
      OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : "",
      Symbol: isSet(object.Symbol) ? globalThis.String(object.Symbol) : "",
      Timestamp: isSet(object.Timestamp) ? fromJsonTimestamp(object.Timestamp) : undefined,
      Period: isSet(object.Period) ? Period.fromJSON(object.Period) : undefined,
      MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
      UserID: isSet(object.UserID) ? globalThis.String(object.UserID) : undefined,
      Value: globalThis.Array.isArray(object?.Value) ? object.Value.map((e: any) => Value.fromJSON(e)) : [],
      Series: isSet(object.Series) ? seriesFromJSON(object.Series) : 0,
      Source: isSet(object.Source) ? sourceFromJSON(object.Source) : undefined,
    };
  },

  toJSON(message: AED): unknown {
    const obj: any = {};
    if (message.OrganizationID !== "") {
      obj.OrganizationID = message.OrganizationID;
    }
    if (message.Symbol !== "") {
      obj.Symbol = message.Symbol;
    }
    if (message.Timestamp !== undefined) {
      obj.Timestamp = message.Timestamp.toISOString();
    }
    if (message.Period !== undefined) {
      obj.Period = Period.toJSON(message.Period);
    }
    if (message.MetaData !== undefined) {
      obj.MetaData = MetaData.toJSON(message.MetaData);
    }
    if (message.UserID !== undefined) {
      obj.UserID = message.UserID;
    }
    if (message.Value?.length) {
      obj.Value = message.Value.map((e) => Value.toJSON(e));
    }
    if (message.Series !== 0) {
      obj.Series = seriesToJSON(message.Series);
    }
    if (message.Source !== undefined) {
      obj.Source = sourceToJSON(message.Source);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AED>, I>>(base?: I): AED {
    return AED.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AED>, I>>(object: I): AED {
    const message = createBaseAED();
    message.OrganizationID = object.OrganizationID ?? "";
    message.Symbol = object.Symbol ?? "";
    message.Timestamp = object.Timestamp ?? undefined;
    message.Period = (object.Period !== undefined && object.Period !== null)
      ? Period.fromPartial(object.Period)
      : undefined;
    message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
      ? MetaData.fromPartial(object.MetaData)
      : undefined;
    message.UserID = object.UserID ?? undefined;
    message.Value = object.Value?.map((e) => Value.fromPartial(e)) || [];
    message.Series = object.Series ?? 0;
    message.Source = object.Source ?? undefined;
    return message;
  },
};

function createBaseValue(): Value {
  return { Field: 0, StringVal: undefined, Int64Val: undefined, Float64Val: undefined, BoolVal: undefined };
}

export const Value = {
  encode(message: Value, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Field !== 0) {
      writer.uint32(8).int32(message.Field);
    }
    if (message.StringVal !== undefined) {
      writer.uint32(18).string(message.StringVal);
    }
    if (message.Int64Val !== undefined) {
      writer.uint32(24).int64(message.Int64Val);
    }
    if (message.Float64Val !== undefined) {
      writer.uint32(33).double(message.Float64Val);
    }
    if (message.BoolVal !== undefined) {
      writer.uint32(40).bool(message.BoolVal);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Value {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.Field = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.StringVal = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Int64Val = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.Float64Val = reader.double();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.BoolVal = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Value {
    return {
      Field: isSet(object.Field) ? fieldFromJSON(object.Field) : 0,
      StringVal: isSet(object.StringVal) ? globalThis.String(object.StringVal) : undefined,
      Int64Val: isSet(object.Int64Val) ? globalThis.Number(object.Int64Val) : undefined,
      Float64Val: isSet(object.Float64Val) ? globalThis.Number(object.Float64Val) : undefined,
      BoolVal: isSet(object.BoolVal) ? globalThis.Boolean(object.BoolVal) : undefined,
    };
  },

  toJSON(message: Value): unknown {
    const obj: any = {};
    if (message.Field !== 0) {
      obj.Field = fieldToJSON(message.Field);
    }
    if (message.StringVal !== undefined) {
      obj.StringVal = message.StringVal;
    }
    if (message.Int64Val !== undefined) {
      obj.Int64Val = Math.round(message.Int64Val);
    }
    if (message.Float64Val !== undefined) {
      obj.Float64Val = message.Float64Val;
    }
    if (message.BoolVal !== undefined) {
      obj.BoolVal = message.BoolVal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Value>, I>>(base?: I): Value {
    return Value.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Value>, I>>(object: I): Value {
    const message = createBaseValue();
    message.Field = object.Field ?? 0;
    message.StringVal = object.StringVal ?? undefined;
    message.Int64Val = object.Int64Val ?? undefined;
    message.Float64Val = object.Float64Val ?? undefined;
    message.BoolVal = object.BoolVal ?? undefined;
    return message;
  },
};

function createBasePeriod(): Period {
  return { Type: 0, Duration: 0 };
}

export const Period = {
  encode(message: Period, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Type !== 0) {
      writer.uint32(8).int32(message.Type);
    }
    if (message.Duration !== 0) {
      writer.uint32(16).int32(message.Duration);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Period {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeriod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.Type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.Duration = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Period {
    return {
      Type: isSet(object.Type) ? periodTypeFromJSON(object.Type) : 0,
      Duration: isSet(object.Duration) ? globalThis.Number(object.Duration) : 0,
    };
  },

  toJSON(message: Period): unknown {
    const obj: any = {};
    if (message.Type !== 0) {
      obj.Type = periodTypeToJSON(message.Type);
    }
    if (message.Duration !== 0) {
      obj.Duration = Math.round(message.Duration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Period>, I>>(base?: I): Period {
    return Period.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Period>, I>>(object: I): Period {
    const message = createBasePeriod();
    message.Type = object.Type ?? 0;
    message.Duration = object.Duration ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
